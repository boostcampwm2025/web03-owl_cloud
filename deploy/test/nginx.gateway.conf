# ingress용 nginx라고 생각하면 좋을것 같습니다.
server {
  listen 80;

  # 아래 설정은 원래 성능을 위해서 추가하려고 했으나 조사 결과 NEXT 자체가 이미 압축하는 방향이 있어서 둘이 있으면 겹친다고 하더군요.. 그래서 삭제하는 방향으로 갔습니다.
  # gzip on;
  # gzip_comp_level 5;
  # gzip_min_length 1024;
  # gzip_vary on;
  # gzip_types
  #   text/plain text/css text/xml application/xml application/json
  #   application/javascript text/javascript application/rss+xml
  #   image/svg+xml;

  # Docker Dns로 TTL 주기마다 DNS를 재조회 한다.
  resolver 127.0.0.11 ipv6=off;


  # keep alive 설정 
  proxy_http_version 1.1;
  proxy_set_header Connection "";

  proxy_set_header Host              $host;
  proxy_set_header X-Real-IP         $remote_addr;
  proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
  proxy_set_header X-Forwarded-Proto $scheme;

  # sse를 위한 수정 - gateway도 수정해 줘야 백엔드에서 받을 수 있다. ( 백엔드 쪽이 살아있어도 gateway가 죽으면 의미가 없기에 )
  location ~ ^/api/cards/sse$ {
    proxy_pass http://main-backend-nginx;

    proxy_http_version 1.1;
    proxy_set_header Connection "";

    proxy_buffering off;
    proxy_cache off;
    add_header X-Accel-Buffering no;

    proxy_read_timeout 3600s;
    proxy_send_timeout 3600s;

    proxy_request_buffering off;
    gzip off;

  }

  # backend 프록시 전달
  location /api/ {
    # Dns 탐색
    proxy_pass http://main-backend-nginx;

    client_max_body_size 10m;
    proxy_connect_timeout 5s;
    proxy_send_timeout 1m;
    proxy_read_timeout 1m;

  }

  # NEXT용 static caching
  # NEXT는 자체적으로 해시화가 있어서 장기 캐싱에도 안전하다고 합니다.
  location /_next/static/ {
    proxy_pass http://frontend:3000;
    expires 1y;
    add_header Cache-Control "public, immutable";
    access_log off;
  }

  # 나머지는 frontend로 전달
  location / {
    proxy_pass http://frontend:3000;

    # frontend는 연결 시간을 짧게 잡아서 유저가 오류를 빨리 찾아낼 수 있도록 설정합니다.
    proxy_connect_timeout 3s;
    proxy_send_timeout 30s;
    proxy_read_timeout 30s;
  }

}