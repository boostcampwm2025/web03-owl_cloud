# 80으로 오는건 리다이렉트를 해준다.
server {
  listen 80;
  server_name www.devmeet-test.p-e.kr;

  # 이도메인 주소가 맞는지 확인하는 로직
  location /.well-known/acme-challenge/ {
    root /var/www/certbot;
  }

  # https로 리다이렉트
  location / {
    return 301 https://$host$request_uri;
  }
}

# ingress용 nginx라고 생각하면 좋을것 같습니다.
server {
  # http2를 이용해서 tls 핸드세이킹을 진행한다.
  listen 443 ssl http2;
  server_name www.devmeet-test.p-e.kr;

  # TLS 1.2 이상만 허용하고 TLS1.3은 ECDHE를 강제한다. 
  ssl_certificate     /etc/letsencrypt/live/www.devmeet-test.p-e.kr/fullchain.pem; 
  ssl_certificate_key /etc/letsencrypt/live/www.devmeet-test.p-e.kr/privkey.pem;

  # Docker Dns로 TTL 주기마다 DNS를 재조회 한다. ( 10초 마다 확인하기 )
  resolver 127.0.0.11 ipv6=off valid=10s;
  resolver_timeout 2s;

  # http 1.1 사용
  proxy_http_version 1.1;

  proxy_set_header Host              $host;
  proxy_set_header X-Real-IP         $remote_addr;
  proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
  proxy_set_header X-Forwarded-Proto $scheme;

  # 443에서도 이 도메인이 정말 주인인지 확인하는 로직이 필요하다. 
  location /.well-known/acme-challenge/ {
    root /var/www/certbot;
  }

  # 백엔드도 DNS를 항상 조회하게 해야 한다.
  set $main_backend_upstream http://main-backend-nginx;

  # 웹소켓 관련 추가
  # 리다이렉트도 추가
  location = /api/ws {
    return 301 /api/ws/;
  } 

  location ^~ /api/ws/ {
    proxy_pass $main_backend_upstream;

    # 전역적으로 설정했지만 안전성을 위해서 한번 더
    proxy_http_version 1.1;

    # 웹소켓 업그레이드 
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";

    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;

    # 연결 높이기 
    proxy_read_timeout 3600s;
    proxy_send_timeout 3600s;

    # 실시간 성을 위해서 추가
    proxy_buffering off;
  }

  # sse를 사용을 위한 부분
  location ^~ /api/sse/ {
    proxy_pass $main_backend_upstream;

    # keep alive 설정
    proxy_http_version 1.1;
    proxy_set_header Connection "";

    proxy_buffering off;
    proxy_cache off;
    add_header X-Accel-Buffering no;

    proxy_read_timeout 3600s;
    proxy_send_timeout 3600s;

    proxy_request_buffering off;
    # gzip을 확실히 잡는다.
    proxy_set_header Accept-Encoding "";
    gzip off;
    add_header Cache-Control "no-cache";

    # 응답을 한번에 다 보내는게 아닌 조각 단위로 계속 나누어서 보내도록 설정
    # chunked_transfer_encoding on;
  }

  # main_backend 프록시 전달
  location /api/ { 
    # Dns 탐색
    proxy_pass $main_backend_upstream;

    # keep alive 설정
    proxy_set_header Connection "";

    client_max_body_size 10m;
    proxy_connect_timeout 5s;
    proxy_send_timeout 1m;
    proxy_read_timeout 1m;

  }

  # tool_backend도 웹소켓을 열어주어야 한다. 
  location = /tool/ws {
    return 301 /tool/ws/;
  }

  location ^~ /tool/ws/ {
    proxy_pass $tool_backend_upstream;

    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";

    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host  $host;

    proxy_read_timeout 3600s;
    proxy_send_timeout 3600s;

    proxy_buffering off;
  }

  # tool_backend 프록시 전달
  set $tool_backend_upstream http://tool-backend-nginx;
  location /tool/ { 
    # Dns 탐색
    proxy_pass $tool_backend_upstream;

    # keep alive 설정
    proxy_set_header Connection "";

    client_max_body_size 10m;
    proxy_connect_timeout 5s;
    proxy_send_timeout 1m;
    proxy_read_timeout 1m;

  }

  # 아래 설정은 원래 성능을 위해서 추가하려고 했으나 조사 결과 NEXT 자체가 이미 압축하는 방향이 있어서 둘이 있으면 겹친다고 하더군요.. 그래서 삭제하는 방향으로 갔습니다.
  # gzip on;
  # gzip_comp_level 5;
  # gzip_min_length 1024;
  # gzip_vary on;
  # gzip_types
  #   text/plain text/css text/xml application/xml application/json
  #   application/javascript text/javascript application/rss+xml
  #   image/svg+xml;

  # 항상 DNS를 재조회 하도록 해서 안정성을 높인다.
  set $frontend_upstream http://frontend-nginx;

  # NEXT용 static caching
  # NEXT는 자체적으로 해시화가 있어서 장기 캐싱에도 안전하다고 합니다.
  location /_next/static/ {
    proxy_pass $frontend_upstream;
    expires 1y;
    add_header Cache-Control "public, immutable" always;
    access_log off;
  }

  location ^~ /_next/image {
    proxy_pass $frontend_upstream;
    expires 1h;
    add_header Cache-Control "public" always;
  }  

  # 나머지는 frontend로 전달
  location / {
    proxy_pass $frontend_upstream;

    # keep alive 설정
    proxy_set_header Connection "";

    # frontend는 연결 시간을 짧게 잡아서 유저가 오류를 빨리 찾아낼 수 있도록 설정합니다.
    proxy_connect_timeout 3s;
    proxy_send_timeout 30s;
    proxy_read_timeout 60s;
  }

}