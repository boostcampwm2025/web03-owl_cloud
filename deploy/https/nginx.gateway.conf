# https 요청을 처리할 수 있도록 nginx를 설정하였습니다 마찬 가지로 추후 kubernetes를 이용한다면 이부분도 수정이 될거에요
server {
  listen 80;
  server_name www.clobby.p-e.kr;

  # 인증서 경로
  location /.well-known/acme-challenge/ {
    root /var/www/certbot;
  }

  # https로 리다이렉트
  location / {
    return 301 https://$host$request_uri;
  }
}

server {
  # http2를 우선적으로 이용할 것이고 TLS연결을 진행할 것이다.
  listen 443 ssl http2;
  server_name www.clobby.p-e.kr;

  # TLS1.2만 허용할 것이고 TLS1.3은 ECDHE을 강제한다.
  ssl_certificate     /etc/letsencrypt/live/www.clobby.p-e.kr/fullchain.pem; 
  ssl_certificate_key /etc/letsencrypt/live/www.clobby.p-e.kr/privkey.pem;

  # 기본 적인 설정
  proxy_set_header Host              $host;
  proxy_set_header X-Real-IP         $remote_addr;
  proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
  proxy_set_header X-Forwarded-Proto $scheme;

  # 443에도 certbot을 확인할 수 있도록 수정
  location /.well-known/acme-challenge/ {
    root /var/www/certbot;
  }

  # Docker에 dns 서버
  # 최대 10초까지만 같은 이름을 쓰고 2초 까지 기다린다
  resolver 127.0.0.11 ipv6=off valid=10s;
  resolver_timeout 2s;

  set $backend_upstream http://main-backend-nginx;

  # websocket 연결 설정 ( test 서버와 거의 동일 )
  location = /api/ws {
    return 301 /api/ws/;
  } 

  location ^~ /api/ws/ {
    proxy_pass $backend_upstream;

    # 전역적으로 설정했지만 안전성을 위해서 한번 더
    proxy_http_version 1.1;

    # 웹소켓 업그레이드 
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";

    proxy_set_header Host              $host;
    proxy_set_header X-Real-IP         $remote_addr;
    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header X-Forwarded-Host $host;

    # 연결 높이기 
    proxy_read_timeout 3600s;
    proxy_send_timeout 3600s;

    # 실시간 성을 위해서 추가
    proxy_buffering off;
  }


  # test와 마찬가지로 sse 연결에 대해서 설정을 해두는 것이 중요하다. -> 지금은 사용하지 않지만 마지막에 sse가 있으면 이를 이용하도록 할 예정이다.
  location ^~ /api/sse/ {
    proxy_pass $backend_upstream;

    # keep alive 설정
    proxy_http_version 1.1;
    proxy_set_header Connection "";

    proxy_buffering off;
    proxy_cache off;
    add_header X-Accel-Buffering no;

    proxy_read_timeout 3600s;
    proxy_send_timeout 3600s;

    proxy_request_buffering off;
    gzip off;
    add_header Cache-Control "no-cache, no-store";

    # 응답을 한번에 다 보내는게 아닌 조각 단위로 계속 나누어서 보내도록 설정
    chunked_transfer_encoding on;
  }

  # backend로 연결
  location /api/ {
    proxy_pass $backend_upstream;

    # keep alive 사용을 위한 체크
    proxy_http_version 1.1;
    proxy_set_header Connection "";

    # gateway도 설정을 안하면 api가 기다리든 말든 끊어버리니 api gateway도 설정을 해주는 것이 중요하다. -> 나중에 업로드 api만 따로 변경
    client_max_body_size 10m;
    proxy_connect_timeout 5s;
    proxy_send_timeout 1m;
    proxy_read_timeout 1m;
  }

  set $frontend_upstream http://frontend:3000;

  # NEXT에 캐싱서버 -> NEXT는 기본적으로 압축하는 로직이 존재한다. 
  location /_next/static/ {
    proxy_pass $frontend_upstream;
    expires 1y;
    add_header Cache-Control "public, immutable";
    access_log off;
  }

  location / {
    proxy_pass $frontend_upstream;

    proxy_http_version 1.1;
    proxy_set_header Connection "";

    # 연결 지연시간 설정
    proxy_connect_timeout 3s;
    proxy_send_timeout 30s;
    proxy_read_timeout 30s;
  }

}